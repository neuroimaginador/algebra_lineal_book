# Problemas Resueltos {#problems}

```{r echo = FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      results = "asis",
                      message = FALSE,
                      warning = FALSE)

set.seed(4321)
``` 

En este capítulo planteamos varios problemas que recorren la mayoría de los contenidos de este libro y que intentan poner en práctica todas las técnicas de cada tema.

En cada problema resuelto, se hará referencia a la sección donde se ha dado la explicación que ayuda a la resolución del ejercicio.

## Espacios Vectoriales {#prob-ev}
```{r}
# Dimensión del espacio V
n <- 4#sample(4:5, size = 1)

# Definición de dos subespacios U y W
## Dimensiones
n_U <- sample(1:(n - 2), size = 1)
# n_W <- sample(1:(n - n_U), size = 1)
## Matrices aleatorias para sus cartesianas
A_U <- rMatrix(n = n_U, m = n, values = -1:3)
# A_W <- rMatrix(n = n_W, m = n, values = -1:3)

eqns_U <- write_system(A_U, b = matlab::zeros(c(nrow(A_U), 1))) %>%   str_flatten(", ")

# eqns_W <- write_system(A_W, b = matlab::zeros(c(nrow(A_W), 1))) %>%   str_flatten(", ")

vec0 <- matlab::zeros(c(n, 1))

# Hallar una base de U y W
genU <- solve_homogeneous(A_U)
bU <- linearly_independents(genU)
dim_U <- ncol(bU)

scalars <- rVector(n = dim_U)
genW <- cbind(bU %*% scalars, rMatrix(n, m = 1))
A_W <- parametric_to_cartesian(genW)$A %>% 
  remove_fraction()

# genW <- solve_homogeneous(A_W)
bW <- linearly_independents(genW)
dim_W <- ncol(bW)

# Calcular una base y la dimensión de:
# (a) U \cap W
A_Intersect <- rbind(A_U, A_W)
gen_Intersect <- solve_homogeneous(A_Intersect)
b_Intersect <- linearly_independents(gen_Intersect)
dim_Intersect <- ncol(b_Intersect)

# (b) U + W
gen_Sum <- cbind(bU, bW)
b_Sum <- linearly_independents(gen_Sum)
dim_Sum <- ncol(b_Sum)

# Comprobar el teorema de la dimensión
se_cumple <- dim_Sum == dim_U + dim_W - dim_Intersect

# Cambio de base
# Generar una base aleatoria y encontrar lo cambios a 
# y desde la canónica
repeat {
  
  B1 <- rMatrix(n = n, m = n * 4, values = -1:1)
  B1 <- linearly_independents(B1)

  if (ncol(B1) == n) break
  
}

# De B1 a C es trivial, es la propia B1.
# De C a B1 es su inversa.
P <- gauss_elimination(B1, eye(n), jordan = TRUE, diag1 = TRUE)

# Generar un vector aleatorio y expresarlo en las coordenadas
# de la base nueva
scalars <- matrix(sample(-2:4, size = n, replace = TRUE), ncol = 1)
v <- B1 %*% scalars
coord <- gauss_elimination(B1, v, jordan = FALSE, diag1 = FALSE)

unknowns <- c("x", "y", "z", "t", "u")[seq(n)]
generic_vector <- matrix(unknowns, ncol = 1)
```


__Ejercicio__

Consideremos como espacio vectorial $V = \mathbb{R}^{`r n`}$ y los subespacios siguientes:

```{r}
glue::glue("$$U = \\left\\{",
           "[to_latex(generic_vector)] \\in\\mathbb{R}^{[n]}:",
           "[str_flatten(write_system(A_U, b = zeros(n, 1), latex = TRUE, format = 'c'))]",
           "\\right\\}$$",
           .open = "[", .close = "]") %>% 
  cat()
glue::glue("$$W = \\left\\{",
           "[to_latex(generic_vector)] \\in\\mathbb{R}^{[n]}:",
           "[str_flatten(write_system(A_W, b = zeros(n, 1), latex = TRUE, format = 'c'))]",
           "\\right\\}$$",
           .open = "[", .close = "]") %>% 
  cat()

```

a. Hallar la dimensión y una base de $U$ y de $W$.
b. Hallar la dimensión y una base de $U\cap W$ y de $U+W$.
c. Comprobar el teorema de la dimensión.
d. Encontrar el subespacio suplementario de $U$.
e. Consideremos el vector $v$ dado por sus coordenadas en la base canónica \( `r glue::glue("{to_latex(v)}")` \). Consideremos también la base:

```{r}
glue::glue(
  "$$",
  "\\mathcal{B}_{1} = ",
  "\\left\\{[vectors_to_latex(B1)]\\right\\}",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

Encontrar las coordenadas de $v$ en la nueva base.

f. Encontrar las matrices de cambio de base entre $\mathcal{B}_1$ y $\mathcal{C}$ (en ambos sentidos), siendo $\mathcal{C}$ la base canónica.

__Solución__


a. Para encontrar unas bases de $U$ y de $W$ podemos seguir las indicaciones sobre [cómo encontrar un sistema generador y una base a partir de la descripción de un subespacio](#base).

En el caso del subsepacio $U$, el sistema homogéneo dado por su ecuaciones cartesianas es:

```{r}
glue::glue("$$\\left\\{",
           "[str_flatten(write_system(A_U, b = zeros(n, 1), latex = TRUE))]",
           "\\right.$$",
           .open = "[", .close = "]") %>% 
  cat()
```

Este sistema, resuelto por Gauss, nos da las siguientes expresiones paramétricas:
```{r}
params <- c("\\alpha", "\\beta", "\\delta", "\\gamma")
glue::glue(
  "$$",
  "[to_latex(generic_vector)] = ",
  "[write_linear_combination(genU, vars = params)]",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

De estas paramétricas podemos [extraer un sistema generador](#base) y, [a partir de él, la base de $U$](#sistgenabase):
```{r}
glue::glue(
  "$$",
  "\\mathcal{B}_{U} = ",
  "\\left\\{[vectors_to_latex(bU)]\\right\\}",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

Y, así, $\mathrm{dim}(U) = `r ncol(bU)`$.

Repetimos todo el proceso para el subespacio $W$. Tomamos su sistema homogéneo asociado:

```{r}
glue::glue("$$\\left\\{",
           "[str_flatten(write_system(A_W, b = zeros(n, 1), latex = TRUE))]",
           "\\right.$$",
           .open = "[", .close = "]") %>% 
  cat()
```

Lo resolvemos por Gauss para obtener las ecuaciones paramétricas del conjunto solución:
```{r}
params <- c("\\alpha", "\\beta", "\\delta", "\\gamma")
PW <- gauss_elimination(A_W, matlab::zeros(nrow(A_W), 1))
glue_latex(
  "[glue_matrices(A_W, matlab::zeros(nrow(A_W), 1), latex = TRUE, fractions = TRUE)]",
  "\\sim",
  "[glue_matrices(PW$splits, latex = TRUE, fractions = TRUE)]",
  "\\Rightarrow\\quad\\ ",
  "[to_latex(generic_vector)] = ",
  "[write_linear_combination(genW, vars = params)]"
) %>% 
  cat()
```

Por tanto, una base de $W$ será:
```{r}
glue::glue(
  "$$",
  "\\mathcal{B}_{W} = ",
  "\\left\\{[vectors_to_latex(bW)]\\right\\}",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

Y, así, $\mathrm{dim}(W) = `r ncol(bW)`$.

b. El subespacio intersección $U\cap W$ es [el conjunto de vectores que verifican tanto las ecuaciones cartesianas de $U$ como las de $W$](#interseccion). Es decir, son el conjunto solución del sistema homogéneo:
```{r}
glue::glue("$$\\left\\{",
           "[str_flatten(write_system(A_Intersect, b = zeros(n, 1), latex = TRUE))]",
           "\\right.$$",
           .open = "[", .close = "]") %>% 
  cat()
```

```{r}

if (ncol(b_Intersect) > 0) {
  
params <- c("\\alpha", "\\beta", "\\delta", "\\gamma")
glue::glue(
  "Este sistema, resuelto por Gauss, nos da las siguientes expresiones paramétricas:\n",
  "$$",
  "[to_latex(generic_vector)] = ",
  "[write_linear_combination(gen_Intersect, vars = params)]",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
  
} else {
  
  glue::glue("Este sistema es compatible determinado, luego su única solución es el vector 0.") %>% 
    cat()
  
}
```

```{r}
if (ncol(b_Intersect) > 0) {
  
glue::glue(
  "Por tanto, una base de $U\\cap W$ será:\n",
  "$$",
  "\\mathcal{B}_{U\\cap W} = ",
  "\\left\\{[vectors_to_latex(b_Intersect)]\\right\\}",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
  
} else {
  
  glue::glue(
    "Luego:",
    "$$",
    "U\\cap W = \\{ 0 \\}",
    "$$",
    .open = "[", .close = "]"
  ) %>% 
    cat()
  
}

```

Y, así, $\mathrm{dim}(U\cap W) = `r ncol(b_Intersect)`$.

Para la suma $U+W$, [sabemos que $\mathcal{B}_U\cup\mathcal{B}_W$ es un sistema generador](#suma):

```{r}
glue::glue(
  "$$",
  "\\mathcal{B}_{U}\\cup\\mathcal{B}_{W} = ",
  "\\left\\{[vectors_to_latex(cbind(bU, bW))]\\right\\}",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

Basta con usar eliminación gaussiana en ese conjunto de vectores para [eliminar aquellos que sean linealmente dependientes](#sistgenabase).
```{r}

s <- gauss_elimination(t(cbind(bU, bW)))

cat("$$", to_latex(cbind(t(cbind(bU, bW))), fractions = TRUE), "\\sim", to_latex(cbind(s$U), fractions = TRUE), "$$")
```

Aquellas filas que hayan acabado siendo enteras de ceros, se corresponden con vectores que originalmente eran dependientes linealmente de los demás.

Por tanto, eliminándolos, tenemos una base de $U+W$:
```{r}
glue::glue(
  "$$",
  "\\mathcal{B}_{U + W} = ",
  "\\left\\{[vectors_to_latex(b_Sum)]\\right\\}",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

Y, así, $\mathrm{dim}(U+W) = `r ncol(b_Sum)`$.

c. Podemos comprobar [el teorema de la dimensión](#th-dim):

$$\begin{array}{ccccccc}
\mathrm{dim}(U+W) & = & \mathrm{dim}(U) & + & \mathrm{dim}(W) & - & \mathrm{dim}(U\cap V) \\
`r dim_Sum` & = & `r dim_U` & + & `r dim_W` & - & `r dim_Intersect` \\
\end{array}$$

d. Calculemos [el espacio suplementario de $U$](#supl).

Tomamos una base de $U$, como la calculada antes, y le aplicamos Gauss para obtener un sistema de vectores en forma escalonada.

```{r}
PU <- gauss_elimination(t(bU), jordan = TRUE)
M <- PU$U
# Pivotes
  if (nrow(M) == 1) {

    pivots_idx <- which(M != 0)[1]
    params_idx <- setdiff(seq(ncol(M)),
                          pivots_idx)

  } else {

    pivots_idx <- apply(M, 1, function(r) which(r != 0)[1])
    pivots_idx_final <- pivots_idx[!is.na(pivots_idx)]

    params_idx <- setdiff(seq(ncol(M)), pivots_idx_final)

  }

# Canónica
C <- eye(n)

# Solo aquellos vectores de los que no tienen 1 
# en las posiciones de los pivotes
b_suplU <- matrix(C[, -pivots_idx], nrow = n)
```

```{r}
glue_latex(
  "[glue_matrices(t(bU), latex = TRUE, fractions = TRUE)]",
  "\\sim",
  "[glue_matrices(PU$splits, latex = TRUE, fractions = TRUE)]"
) %>% 
  cat()
```

Siguiendo las instrucciones de la [sección acerca del espacio suplementario](#supl), vamos a fijarnos en qué columnas están los pivotes: \(\{ `r str_flatten(pivots_idx, ", ")` \}\). 

De la base canónica $\mathcal{C}$ eliminamos aquellos vectores que tienen un 1 en las mismas posiciones que los pivotes. Lo que nos quede, ésa es la base del espacio suplementario de $U$:
```{r}
glue_latex(
  "\\mathcal{B}_{\\mathrm{supl}} =",
  "\\left\\{",
  "[vectors_to_latex(b_suplU)]",
  "\\right\\}"
) %>% cat()
```

```{r}
params <- letters[seq(ncol(B1))]
str <- c("$", str_flatten(params, ", "), "$") %>% str_flatten()
```

e. Unos escalares `r str` serán [las coordenadas de $v$ en la base $\mathcal{B}_1$ si se verifica](#coord):

\small
```{r}
glue::glue(
  "$$",
  "[to_latex(v)] = [write_linear_combination(B1, vars = params)]",
  "$$",
  .open = "[", .close = "]"
  
) %>% 
  cat()
```

\normalsize
lo que equivale al siguiente sistema de ecuaciones lineales, que se puede resolver usando métodos Gaussianos, y nos da:
```{r}
glue::glue(
  "$$\\left\\{",
  "[str_flatten(write_system(B1, v, latex = TRUE, vars = params))]",
  "\\right.",
  "\\Rightarrow",
  " v = [to_latex(matrix(params, ncol = 1))]_{\\mathcal{B}_1} = [to_latex(scalars)]_{\\mathcal{B}_1}",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

f. El procedimiento para construir la [matriz de cambio de base](#cambiobase) de una base $\mathcal{B}$ a otra $\mathcal{B}'$ es el siguiente:

- Calcular las coordenadas de cada vector en $\mathcal{B}$ en la base $\mathcal{B}'$. Eso supone la resolución de $n$ sistemas de ecuaciones lineales, y el procedimiento es igual que el visto en la sección anterior.
- Construir la matriz poniendo, en forma de columna, las coordenadas calculadas: la primera columna se corresponde con las calculadas para el primer vector de $\mathcal{B}$, la segunda columna, para las del segundo, etc.

Otro aspecto teórico importante es que la matriz de $\mathcal{B}$ a $\mathcal{B}'$ es la inversa de la del cambio de base de $\mathcal{B}'$ a $\mathcal{B}$. Si una de ellas es fácil de calcular, la otra se puede construir usando, por ejemplo, el método de Gauss-Jordan para el cálculo de inversas.

Hay un caso fácil: el cambio de base desde $\mathcal{B}_1$ a la base canónica $\mathcal{C}$ es la propia matriz cuyas columnas son los vectores de $\mathcal{B}_1$:
```{r}
glue::glue(
  "$$P_{\\mathcal{B}_1\\to\\mathcal{C}} = ",
  "[to_latex(B1)]",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

La matriz del cambio de base opuesto la vamos a calcular [buscando la matriz inversa](#cambiobase) de la de $\mathcal{B}_1$ a $\mathcal{C}$.

Para ello, se puede usar la eliminación de Gauss-Jordan:
```{r}
glue::glue(
  "$$",
  "[glue_matrices(B1, eye(n), latex = TRUE)]",
  "\\sim",
  "[glue_matrices(P$splits, fractions = TRUE, latex = TRUE)]",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

Luego
```{r}
glue::glue(
  "$$P_{\\mathcal{C}\\to\\mathcal{B}_1} = ",
  "[to_latex(P$splits[[2]],fractions = TRUE)]",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```


## Aplicaciones lineales {#prob-apli}

```{r, results = "asis"}
unknowns <- c("x", "y", "z", "t")
n <- dimV <- sample(3:4, size = 1)
m <- dimW <- sample(2:3, size = 1)

A <- rMatrix(n = dimW, m = dimV)

str0 <- to_latex(matrix(unknowns[seq(dimV)], ncol = 1))

str <- write_system(A, latex = TRUE, format = "c")

repeat {
  
  B1 <- rMatrix(n = n, m = n * 4, values = -2:1)
  B1 <- linearly_independents(B1)

  if (ncol(B1) == n) break
  
}

repeat {
  
  B2 <- rMatrix(n = m, m = m * 4, values = 0:2)
  B2 <- linearly_independents(B2)

  if (ncol(B2) == m) break
  
}

gen_vector_V <- matrix(get_unknowns(m = n, 
                                    latex = TRUE), 
                       ncol = 1)
```


__Ejercicio__

Consideremos la aplicación $f:V=\mathbb{R}^{`r dimV`}\to W=\mathbb{R}^{`r dimW`}$ dada por:

```{r results="asis"}
cat("$$f", str0, " = \\left(", str, "\\right)$$")
```

a. Encontrar la matriz asociada a $f$ en las bases canónicas y en las bases:
```{r}
glue_latex(
  "\\mathcal{B}_{1} = \\{v_i\\} = ",
  "\\left\\{[vectors_to_latex(B1)]\\right\\}"
) %>% 
  cat()

glue_latex(
  "\\mathcal{B}_{2} = \\{w_i\\} = ",
  "\\left\\{[vectors_to_latex(B2)]\\right\\}"
) %>% 
  cat()
```

b. Dar una base y la dimensión del núcleo y de la imagen de $f$.

c. Identificar si $f$ es inyectiva o sobreyectiva.

d. Comprobar el teorema de la dimensión de rango y nulidad.

e. Calcular una base de $f(U)$, donde $U$ es el subespacio de $V$ dado por:
```{r}
U <- rMatrix(n = n, m = 2)
AU <- parametric_to_cartesian(U)$A
glue_latex(
  "U = \\left\\{",
  "[to_latex(generic_vector_V)]\\in\\mathbb{R}^{[n]}:",
  "[write_system(AU, matlab::zeros(nrow(AU), 1), latex = TRUE, fractions = TRUE, format = 'c')]",
  "\\right\\}"
) %>% 
  cat()
```


__Solución__

a. Para hallar la [matriz asociada](#matriz-apli) a la aplicación $f$ en las bases canónicas, basta con mirar los coeficientes de las variables $x,y,\ldots$ en la expresión de $f$ y ponerlos por columnas. De esta forma:
```{r}
glue_latex(
  "A =",
  "[glue_matrices(A, latex = TRUE, fractions = TRUE)]"
) %>% 
  cat()
```

Para calcular la matriz $A'$ asociada a $f$ [con respecto a las nuevas bases](#cambiobase-apli), tenemos dos opciones:

1. Calcular la imagen de los vectores de $\mathcal{B}_1$ y encontrar sus coordenadas con respecto a la base $\mathcal{B}_2$, y ponerlas por columnas.
2. Calcular las matrices $P$ y $Q$, de [cambio de base](#cambiobase) desde la canónica en $V$ y en $W$ a $\mathcal{B}_1$ y $\mathcal{B}_2$, respectivamente, y usarlas para calcular $A' = Q^{-1}\ A\ P$.

Ambos caminos son completamente equivalentes y, de hecho, uno se deduce del otro. Por tanto, en cada situación debemos ver cuál de los dos nos puede resultar más sencillo.

En este caso, optamos por el [camino 1](#matriz-apli).

Llamemos $Y = (f(v_1)|f(v_2)|\ldots|f(v_n))$ a la matriz que tiene por columnas las imágenes de los vectores de $\mathcal{B}_1$ mediante $f$:
```{r}
Y <- A %*% B1
glue_latex(
  "Y = ",
  "[glue_matrices(Y, latex = TRUE, fractions = TRUE)]"
)
```
y $B_2 = (w_1|w_2|\ldots|w_m)$ a la matriz que tiene por columnas los vectores de $\mathcal{B}_2$.

Entonces $A' = B_2^{-1}\ Y$, que podemos calcular mediante Gauss-Jordan, partiendo de $(B_2|Y)$ y llegando a $(I_m|A')$:
```{r}
Ap <- gauss_elimination(B2, Y, jordan = TRUE, diag1 = TRUE)
glue_latex(
  "[glue_matrices(B2, Y, latex = TRUE, fractions = TRUE)]",
  "\\sim",
  "[glue_matrices(Ap$splits, latex = TRUE, fractions = TRUE)]"
) %>% 
  cat()
```

Luego 
```{r}
glue_latex(
  "A' =",
  "[glue_matrices(Ap$splits[[2]], latex = TRUE, fractions = TRUE)]"
) %>% 
  cat()
```

b. Comenzamos por estudiar el [núcleo](#nucleo) de $f$.

Sabemos que el núcleo $\mathrm{Ker}\ f$ es el conjunto de vectores $v\in V$ tal que $f(v) = 0$, y que eso coincide con el conjunto de soluciones del sistema de ecuaciones homogéneo cuya matriz de coeficientes es $A$.

Todo esto se resume en que las ecuaciones cartesianas de $\mathrm{Ker}\ f$ son aquellas cuya matriz de coeficientes es $A$:
```{r}
glue_latex(
  "\\mathrm{Ker}\\ f =",
  "\\left\\{",
  "[to_latex(gen_vector_V)]\\in V:",
  "[write_system(A, matlab::zeros(m, 1), latex = TRUE, format = 'c')]",
  "\\right\\}"
)
```

Resolvemos este sistema por Gauss para [encontrar las ecuaciones paramétricas](#base) y, a partir de ahí, una [base](#sisgenabase) del núcleo:
```{r}
zeros_vec <- matlab::zeros(m, 1)
gauss_Ker <- gauss_elimination(A, zeros_vec, jordan = TRUE)
glue_latex(
  "[glue_matrices(A, zeros_vec, latex = TRUE, fractions = TRUE)]",
  "\\sim",
  "[glue_matrices(gauss_Ker$splits, latex = TRUE, fractions = TRUE)]"
) %>% 
  cat()
```
Luego nos quedan las siguientes ecuaciones paramétricas para $\mathrm{Ker}\ f$:
```{r}
genKer <- solve_homogeneous(A)
params <- c("\\alpha", "\\beta", "\\gamma", "\\delta")
glue_latex(
  "[to_latex(gen_vector_V)] =",
  "[write_linear_combination(genKer, vars = params)]"
) %>% 
  cat()
```

Entonces la base del núcleo de $f$ es:
```{r}
glue_latex(
  "\\mathcal{B}_{\\mathrm{Ker}\\ f} = ",
  "\\left\\{",
  "[vectors_to_latex(genKer)]",
  "\\right\\}"
)
```
y \(\mathrm{dim}(\mathrm{Ker}\ f) = `r ncol(genKer)`\).

Con respecto a la imagen de $f$, hemos de recordar que [$\mathrm{Im}\ f$ es el subespacio de $W$ generado por los vectores que forman las columnas de la matriz asociada $A$](#imagen).

Por tanto, un [sistema generador](#gen) de $\mathrm{Im}\ f$ será:
```{r}
glue_latex(
  "\\mathcal{G} =",
  "\\left\\{",
  "[vectors_to_latex(A)]",
  "\\right\\}"
) %>% 
  cat()
```

Desde este sistema generador, [eliminamos los vectores linealmente dependientes](#sisgenabase) para obtener una base de $\mathrm{Im}\ f$. Usamos Gauss con los vectores de $\mathcal{G}$ por _filas_, y eliminamos aquellos que, al final, se hayan convertido en filas de ceros:
```{r}
gauss_Im <- gauss_elimination(t(A))
glue_latex(
  "[glue_matrices(t(A), latex = TRUE, fractions = TRUE)]",
  "\\sim",
  "[glue_matrices(gauss_Im$splits[[1]], latex = TRUE, fractions = TRUE)]"
) %>% 
  cat()
```

Luego
```{r}
bImf <- linearly_independents(A)
glue_latex(
  "\\mathcal{B}_{\\mathrm{Im}\\ f} =",
  "\\left\\{[vectors_to_latex(bImf)]\\right\\}"
)
```
y \(\mathrm{dim}(\mathrm{Im}\ f) = `r ncol(bImf)`\).

c. Para determinar si $f$ es [inyectiva](#inyectividad) o [sobreyectiva](#sobrey), nos fijaremos en las dimensiones de su núcleo y de su imagen:

- $f$ será inyectiva si y solo si se cumple $\mathrm{dim}(\mathrm{Ker}\ f) = 0$. Pero sabemos que \(\mathrm{dim}(\mathrm{Ker}\ f) = `r ncol(genKer)`\), luego $f$ no es inyectiva.
- $f$ será sobreyectiva si y solo si se cumple que \(\mathrm{dim}(\mathrm{Im}\ f) = \mathrm{dim}(W) = \mathrm{dim}(\mathbb{R}^{`r m`})\), y esto sí se cumple, como hemos visto en el apartado anterior,luego $f$ es sobreyectiva.

d. El [teorema de la dimensión para núcleo e imagen](@th-dim-nucleo) dice que $\mathrm{dim}(V) = \mathrm{dim}(\mathrm{Ker}\ f) + \mathrm{dim}(\mathrm{Im}\ f)$. Lo podemos comprobar fácilmente:
$$\begin{array}{ccccc}
\mathrm{dim}(\mathbb{R}^{`r n`}) & = & \mathrm{dim}(\mathrm{Ker}\ f) & + & \mathrm{dim}(\mathrm{Im}\ f) \\
`r n` & = & `r ncol(genKer)` & + & `r ncol(bImf)` \\
\end{array}$$

e. Dado el subespacio $U$, debemos encontrar un sistema de vectores $\mathcal{G}$ que [lo genere](#gen), calcular su imagen $f(\mathcal{G})$, y eso será un sistema generador de $f(U)$. A partir de ahí, podemos [extraer una base](#sisgenabase) de $f(U)$.

Para calcular un sistema generador de $U$, pasamos sus [ecuaciones cartesianas](#base) a paramétricas, usando métodos Gaussianos:
```{r}
glue_latex(
  "\\left\\{[write_system(AU, matlab::zeros(nrow(AU), 1))]\\right.",
  "\\Rightarrow",
  "[to_latex(gen_vector_V)] = [write_linear_combination(U, vars = params)]"
)
```

De aquí podemos determinar una base de $U$, si eliminamos sus vectores linealmente dependientes:
```{r}
bU <- linearly_independents(U)
glue_latex(
  "\\mathcal{B}_U = \\left\\{",
  "[vectors_to_latex(bU)]",
  "\\right\\}"
)
```

Ahora procedemos a calcular $f(\mathcal{B}_U)$:
```{r}
fbU <- A %*% bU
glue_latex(
  "f(\\mathcal{B}_U) = \\left\\{",
  "[vectors_to_latex(fbU)]",
  "\\right\\}"
)
```
que es un sistema generador de $f(U)$. Eliminamos los vectores linealmente dependientes (en este caso es sencillo) para obtener una base de $f(U)$:
```{r}
glue_latex(
  "\\mathcal{B}_{f(U)} =",
  "\\left\\{[vectors_to_latex(fbU)]\\right\\}"
)
```
y así \(\mathrm{dim}(f(U)) = `r ncol(fbU)`\).


## Diagonalización {#prob-diag}

## Espacios Euclídeos {#prob-espeuclideo}

