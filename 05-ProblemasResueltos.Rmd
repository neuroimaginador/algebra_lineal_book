# Problemas Resueltos {#problems}

```{r echo = FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      results = "asis",
                      message = FALSE,
                      warning = FALSE)

set.seed(4321)
``` 

En este capítulo planteamos varios problemas que recorren la mayoría de los contenidos de este libro y que intentan poner en práctica todas las técnicas de cada tema.

En cada problema resuelto, se hará referencia a la sección donde se ha dado la explicación que ayuda a la resolución del ejercicio.

## Espacios Vectoriales {#prob-ev}
```{r}
# Dimensión del espacio V
n <- 4#sample(4:5, size = 1)

# Definición de dos subespacios U y W
## Dimensiones
n_U <- sample(1:(n - 2), size = 1)
# n_W <- sample(1:(n - n_U), size = 1)
## Matrices aleatorias para sus cartesianas
A_U <- rMatrix(n = n_U, m = n, values = -1:3)
# A_W <- rMatrix(n = n_W, m = n, values = -1:3)

eqns_U <- write_system(A_U, b = matlab::zeros(c(nrow(A_U), 1))) %>%   str_flatten(", ")

# eqns_W <- write_system(A_W, b = matlab::zeros(c(nrow(A_W), 1))) %>%   str_flatten(", ")

vec0 <- matlab::zeros(c(n, 1))

# Hallar una base de U y W
genU <- solve_homogeneous(A_U)
bU <- linearly_independents(genU)
dim_U <- ncol(bU)

scalars <- rVector(n = dim_U)
genW <- cbind(bU %*% scalars, rMatrix(n, m = 1))
A_W <- parametric_to_cartesian(genW)$A %>% 
  remove_fraction()

# genW <- solve_homogeneous(A_W)
bW <- linearly_independents(genW)
dim_W <- ncol(bW)

# Calcular una base y la dimensión de:
# (a) U \cap W
A_Intersect <- rbind(A_U, A_W)
gen_Intersect <- solve_homogeneous(A_Intersect)
b_Intersect <- linearly_independents(gen_Intersect)
dim_Intersect <- ncol(b_Intersect)

# (b) U + W
gen_Sum <- cbind(bU, bW)
b_Sum <- linearly_independents(gen_Sum)
dim_Sum <- ncol(b_Sum)

# Comprobar el teorema de la dimensión
se_cumple <- dim_Sum == dim_U + dim_W - dim_Intersect

# Cambio de base
# Generar una base aleatoria y encontrar lo cambios a 
# y desde la canónica
repeat {
  
  B1 <- rMatrix(n = n, m = n * 4, values = -1:1)
  B1 <- linearly_independents(B1)

  if (ncol(B1) == n) break
  
}

# De B1 a C es trivial, es la propia B1.
# De C a B1 es su inversa.
P <- gauss_elimination(B1, eye(n), jordan = TRUE, diag1 = TRUE)

# Generar un vector aleatorio y expresarlo en las coordenadas
# de la base nueva
scalars <- matrix(sample(-2:4, size = n, replace = TRUE), ncol = 1)
v <- B1 %*% scalars
coord <- gauss_elimination(B1, v, jordan = FALSE, diag1 = FALSE)

unknowns <- c("x", "y", "z", "t", "u")[seq(n)]
generic_vector <- matrix(unknowns, ncol = 1)
```


__Ejercicio__

Consideremos como espacio vectorial $V = \mathbb{R}^{`r n`}$ y los subespacios siguientes:

```{r}
glue::glue("$$U = \\left\\{",
           "[to_latex(generic_vector)] \\in\\mathbb{R}^{[n]}:",
           "[str_flatten(write_system(A_U, b = zeros(n, 1), latex = TRUE, format = 'c'))]",
           "\\right\\}$$",
           .open = "[", .close = "]") %>% 
  cat()
glue::glue("$$W = \\left\\{",
           "[to_latex(generic_vector)] \\in\\mathbb{R}^{[n]}:",
           "[str_flatten(write_system(A_W, b = zeros(n, 1), latex = TRUE, format = 'c'))]",
           "\\right\\}$$",
           .open = "[", .close = "]") %>% 
  cat()

```

a. Hallar la dimensión y una base de $U$ y de $W$.
b. Hallar la dimensión y una base de $U\cap W$ y de $U+W$.
c. Comprobar el teorema de la dimensión.
d. Encontrar el subespacio suplementario de $U$.
e. Consideremos el vector $v$ dado por sus coordenadas en la base canónica \( `r glue::glue("{to_latex(v)}")` \). Consideremos también la base:

```{r}
glue::glue(
  "$$",
  "\\mathcal{B}_{1} = ",
  "\\left\\{[vectors_to_latex(B1)]\\right\\}",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

Encontrar las coordenadas de $v$ en la nueva base.

f. Encontrar las matrices de cambio de base entre $\mathcal{B}_1$ y $\mathcal{C}$ (en ambos sentidos), siendo $\mathcal{C}$ la base canónica.

__Solución__


a. Para encontrar unas bases de $U$ y de $W$ podemos seguir las indicaciones sobre [cómo encontrar un sistema generador y una base a partir de la descripción de un subespacio](#base).

En el caso del subsepacio $U$, el sistema homogéneo dado por su ecuaciones cartesianas es:

```{r}
glue::glue("$$\\left\\{",
           "[str_flatten(write_system(A_U, b = zeros(n, 1), latex = TRUE))]",
           "\\right.$$",
           .open = "[", .close = "]") %>% 
  cat()
```

Este sistema, resuelto por Gauss, nos da las siguientes expresiones paramétricas:
```{r}
params <- c("\\alpha", "\\beta", "\\delta", "\\gamma")
glue::glue(
  "$$",
  "[to_latex(generic_vector)] = ",
  "[write_linear_combination(genU, vars = params)]",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

De estas paramétricas podemos [extraer un sistema generador](#base) y, [a partir de él, la base de $U$](#sistgenabase):
```{r}
glue::glue(
  "$$",
  "\\mathcal{B}_{U} = ",
  "\\left\\{[vectors_to_latex(bU)]\\right\\}",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

Y, así, $\mathrm{dim}(U) = `r ncol(bU)`$.

Repetimos todo el proceso para el subespacio $W$. Tomamos su sistema homogéneo asociado:

```{r}
glue::glue("$$\\left\\{",
           "[str_flatten(write_system(A_W, b = zeros(n, 1), latex = TRUE))]",
           "\\right.$$",
           .open = "[", .close = "]") %>% 
  cat()
```

Lo resolvemos por Gauss para obtener las ecuaciones paramétricas del conjunto solución:
```{r}
params <- c("\\alpha", "\\beta", "\\delta", "\\gamma")
PW <- gauss_elimination(A_W, matlab::zeros(nrow(A_W), 1))
glue_latex(
  "[glue_matrices(A_W, matlab::zeros(nrow(A_W), 1), latex = TRUE, fractions = TRUE)]",
  "\\sim",
  "[glue_matrices(PW$splits, latex = TRUE, fractions = TRUE)]",
  "\\Rightarrow\\quad\\ ",
  "[to_latex(generic_vector)] = ",
  "[write_linear_combination(genW, vars = params)]"
) %>% 
  cat()
```

Por tanto, una base de $W$ será:
```{r}
glue::glue(
  "$$",
  "\\mathcal{B}_{W} = ",
  "\\left\\{[vectors_to_latex(bW)]\\right\\}",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

Y, así, $\mathrm{dim}(W) = `r ncol(bW)`$.

b. El subespacio intersección $U\cap W$ es [el conjunto de vectores que verifican tanto las ecuaciones cartesianas de $U$ como las de $W$](#interseccion). Es decir, son el conjunto solución del sistema homogéneo:
```{r}
glue::glue("$$\\left\\{",
           "[str_flatten(write_system(A_Intersect, b = zeros(n, 1), latex = TRUE))]",
           "\\right.$$",
           .open = "[", .close = "]") %>% 
  cat()
```

```{r}

if (ncol(b_Intersect) > 0) {
  
params <- c("\\alpha", "\\beta", "\\delta", "\\gamma")
glue::glue(
  "Este sistema, resuelto por Gauss, nos da las siguientes expresiones paramétricas:\n",
  "$$",
  "[to_latex(generic_vector)] = ",
  "[write_linear_combination(gen_Intersect, vars = params)]",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
  
} else {
  
  glue::glue("Este sistema es compatible determinado, luego su única solución es el vector 0.") %>% 
    cat()
  
}
```

```{r}
if (ncol(b_Intersect) > 0) {
  
glue::glue(
  "Por tanto, una base de $U\\cap W$ será:\n",
  "$$",
  "\\mathcal{B}_{U\\cap W} = ",
  "\\left\\{[vectors_to_latex(b_Intersect)]\\right\\}",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
  
} else {
  
  glue::glue(
    "Luego:",
    "$$",
    "U\\cap W = \\{ 0 \\}",
    "$$",
    .open = "[", .close = "]"
  ) %>% 
    cat()
  
}

```

Y, así, $\mathrm{dim}(U\cap W) = `r ncol(b_Intersect)`$.

Para la suma $U+W$, [sabemos que $\mathcal{B}_U\cup\mathcal{B}_W$ es un sistema generador](#suma):

```{r}
glue::glue(
  "$$",
  "\\mathcal{B}_{U}\\cup\\mathcal{B}_{W} = ",
  "\\left\\{[vectors_to_latex(cbind(bU, bW))]\\right\\}",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

Basta con usar eliminación gaussiana en ese conjunto de vectores para [eliminar aquellos que sean linealmente dependientes](#sistgenabase).
```{r}

s <- gauss_elimination(t(cbind(bU, bW)))

cat("$$", to_latex(cbind(t(cbind(bU, bW))), fractions = TRUE), "\\sim", to_latex(cbind(s$U), fractions = TRUE), "$$")
```

Aquellas filas que hayan acabado siendo enteras de ceros, se corresponden con vectores que originalmente eran dependientes linealmente de los demás.

Por tanto, eliminándolos, tenemos una base de $U+W$:
```{r}
glue::glue(
  "$$",
  "\\mathcal{B}_{U + W} = ",
  "\\left\\{[vectors_to_latex(b_Sum)]\\right\\}",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

Y, así, $\mathrm{dim}(U+W) = `r ncol(b_Sum)`$.

c. Podemos comprobar [el teorema de la dimensión](#th-dim):

$$\begin{array}{ccccccc}
\mathrm{dim}(U+W) & = & \mathrm{dim}(U) & + & \mathrm{dim}(W) & - & \mathrm{dim}(U\cap V) \\
`r dim_Sum` & = & `r dim_U` & + & `r dim_W` & - & `r dim_Intersect` \\
\end{array}$$

d. Calculemos [el espacio suplementario de $U$](#supl).

Tomamos una base de $U$, como la calculada antes, y le aplicamos Gauss para obtener un sistema de vectores en forma escalonada.

```{r}
PU <- gauss_elimination(t(bU), jordan = TRUE)
M <- PU$U
# Pivotes
  if (nrow(M) == 1) {

    pivots_idx <- which(M != 0)[1]
    params_idx <- setdiff(seq(ncol(M)),
                          pivots_idx)

  } else {

    pivots_idx <- apply(M, 1, function(r) which(r != 0)[1])
    pivots_idx_final <- pivots_idx[!is.na(pivots_idx)]

    params_idx <- setdiff(seq(ncol(M)), pivots_idx_final)

  }

# Canónica
C <- eye(n)

# Solo aquellos vectores de los que no tienen 1 
# en las posiciones de los pivotes
b_suplU <- matrix(C[, -pivots_idx], nrow = n)
```

```{r}
glue_latex(
  "[glue_matrices(t(bU), latex = TRUE, fractions = TRUE)]",
  "\\sim",
  "[glue_matrices(PU$splits, latex = TRUE, fractions = TRUE)]"
) %>% 
  cat()
```

Siguiendo las instrucciones de la [sección acerca del espacio suplementario](#supl), vamos a fijarnos en qué columnas están los pivotes: \(\{ `r str_flatten(pivots_idx, ", ")` \}\). 

De la base canónica $\mathcal{C}$ eliminamos aquellos vectores que tienen un 1 en las mismas posiciones que los pivotes. Lo que nos quede, ésa es la base del espacio suplementario de $U$:
```{r}
glue_latex(
  "\\mathcal{B}_{\\mathrm{supl}} =",
  "\\left\\{",
  "[vectors_to_latex(b_suplU)]",
  "\\right\\}"
) %>% cat()
```

```{r}
params <- letters[seq(ncol(B1))]
str <- c("$", str_flatten(params, ", "), "$") %>% str_flatten()
```

e. Unos escalares `r str` serán [las coordenadas de $v$ en la base $\mathcal{B}_1$ si se verifica](#coord):

\small
```{r}
glue::glue(
  "$$",
  "[to_latex(v)] = [write_linear_combination(B1, vars = params)]",
  "$$",
  .open = "[", .close = "]"
  
) %>% 
  cat()
```

\normalsize
lo que equivale al siguiente sistema de ecuaciones lineales, que se puede resolver usando métodos Gaussianos, y nos da:
```{r}
glue::glue(
  "$$\\left\\{",
  "[str_flatten(write_system(B1, v, latex = TRUE, vars = params))]",
  "\\right.",
  "\\Rightarrow",
  " v = [to_latex(matrix(params, ncol = 1))]_{\\mathcal{B}_1} = [to_latex(scalars)]_{\\mathcal{B}_1}",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

f. El procedimiento para construir la [matriz de cambio de base](#cambiobase) de una base $\mathcal{B}$ a otra $\mathcal{B}'$ es el siguiente:

- Calcular las coordenadas de cada vector en $\mathcal{B}$ en la base $\mathcal{B}'$. Eso supone la resolución de $n$ sistemas de ecuaciones lineales, y el procedimiento es igual que el visto en la sección anterior.
- Construir la matriz poniendo, en forma de columna, las coordenadas calculadas: la primera columna se corresponde con las calculadas para el primer vector de $\mathcal{B}$, la segunda columna, para las del segundo, etc.

Otro aspecto teórico importante es que la matriz de $\mathcal{B}$ a $\mathcal{B}'$ es la inversa de la del cambio de base de $\mathcal{B}'$ a $\mathcal{B}$. Si una de ellas es fácil de calcular, la otra se puede construir usando, por ejemplo, el método de Gauss-Jordan para el cálculo de inversas.

Hay un caso fácil: el cambio de base desde $\mathcal{B}_1$ a la base canónica $\mathcal{C}$ es la propia matriz cuyas columnas son los vectores de $\mathcal{B}_1$:
```{r}
glue::glue(
  "$$P_{\\mathcal{B}_1\\to\\mathcal{C}} = ",
  "[to_latex(B1)]",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

La matriz del cambio de base opuesto la vamos a calcular [buscando la matriz inversa](#cambiobase) de la de $\mathcal{B}_1$ a $\mathcal{C}$.

Para ello, se puede usar la eliminación de Gauss-Jordan:
```{r}
glue::glue(
  "$$",
  "[glue_matrices(B1, eye(n), latex = TRUE)]",
  "\\sim",
  "[glue_matrices(P$splits, fractions = TRUE, latex = TRUE)]",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```

Luego
```{r}
glue::glue(
  "$$P_{\\mathcal{C}\\to\\mathcal{B}_1} = ",
  "[to_latex(P$splits[[2]],fractions = TRUE)]",
  "$$",
  .open = "[", .close = "]"
) %>% 
  cat()
```


## Aplicaciones lineales {#prob-apli}

## Diagonalización {#prob-diag}

## Espacios Euclídeos {#prob-espeuclideo}

